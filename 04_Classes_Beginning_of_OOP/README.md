# C++ 클래스 핵심 개념 가이드

## 개요
C++ 클래스와 객체지향 프로그래밍의 핵심 개념들을 정리한 가이드입니다.

---

## C++ 클래스 기본 개념

### C 구조체 vs C++ 클래스
- **C 구조체**: 데이터(변수)만 포함
- **C++ 클래스**: 데이터와 함수(메서드)를 모두 포함
- C++ 클래스는 **데이터와 그 데이터를 처리하는 함수를 하나로 묶는 캡슐화** 기능을 제공
- **객체는 클래스의 인스턴스**로, 클래스를 실제로 메모리에 생성한 것

---

## 생성자와 소멸자

### 생성자 (Constructor)
- **객체가 생성되는 순간 자동으로 호출**되어 **객체의 초기화**를 담당
- **호출 시점**:
  - 자동/정적 변수 선언 시: `MyClass obj;`
  - new 연산자로 동적 할당 시: `MyClass* obj = new MyClass();`

### 소멸자 (Destructor)
- **객체가 소멸되는 순간 자동으로 호출**되어 **객체 소멸 시 정리 작업**을 수행
- **호출 시점**:
  - 스코프를 벗어날 때 (자동/정적 변수의 생명주기 종료)
  - delete 연산자로 해제 시

### 공통 특징
- 생성자와 소멸자 모두 **자동적이고 강제적**으로 호출
- 프로그래머가 직접 호출할 필요가 없음

---

## 메모리 관리

### 동적 메모리 할당과 해제
- **new로 할당한 메모리는 반드시 delete 또는 delete[]로 해제**해야 함
- **C++는 가비지 컬렉션을 기본 지원하지 않으므로** 개발자가 직접 메모리 관리를 담당
- **new와 delete는 쌍을 이루어 사용**해야 하며, 이는 개발자의 책임

```cpp
// 올바른 사용법
MyClass* obj = new MyClass();  // 할당
delete obj;                    // 해제

MyClass* arr = new MyClass[10]; // 배열 할당
delete[] arr;                   // 배열 해제
```

---

## 접근 제어 지시자

### 목적과 역할
- **접근 제어 지시자의 주된 목적은 캡슐화 지원**과 **정보 은닉(Information Hiding) 구현**
- **클래스 외부에서 멤버 접근을 제어**하여 **객체의 내부 상태를 보호**
- **개발자가 의도한 방식대로만 클래스가 사용되도록 제한**하여 **코드의 유지보수성을 향상**

### private 접근 제어자
- **가장 엄격한 접근 제한**을 제공
- **해당 클래스의 멤버 함수 내에서만 접근 가능**
- **상속받은 자식 클래스에서도 접근할 수 없음** (protected와의 주요 차이점)

---

## this 포인터

### 특징
- **'this' 포인터는 멤버 함수를 호출한 특정 객체(인스턴스)의 주소**를 가리킴
- **C++ 컴파일러가 자동으로 전달**하므로 개발자가 명시적으로 선언할 필요가 없음
- **멤버 함수 내에서만 사용 가능**하며, **동일한 클래스의 여러 객체를 구분**하는 역할

```cpp
class MyClass {
private:
    int value;
public:
    void setValue(int value) {
        this->value = value;  // 매개변수와 멤버변수 구분
    }
};
```

---

## const 멤버 함수

### 특징과 장점
- **const 멤버 함수는 객체의 멤버 데이터를 수정하지 않음**을 보장
- **의도치 않은 멤버 데이터 변경을 컴파일 시점에 방지**
- **함수의 부작용(side effect) 없음을 보장**하여 안전한 호출을 가능하게 함
- **const 객체에서는 const 멤버 함수만 호출 가능**

```cpp
class MyClass {
private:
    int value;
public:
    int getValue() const {  // const 멤버 함수
        return value;       // 읽기만 가능, 수정 불가
    }
    
    void print() const {    // const 멤버 함수
        std::cout << value << std::endl;
    }
};
```

---

## static 멤버

### static 멤버의 특징
- **특정 객체에 속하지 않고 클래스 자체에 속함**
- **객체 생성 없이도 접근/호출 가능**하며, 클래스명으로 직접 접근할 수 있음

### static 멤버 변수
- **클래스의 모든 객체가 공유하는 단 하나의 복사본**만 존재
- 메모리 효율성을 제공하며, 클래스 차원의 공통 데이터를 관리할 때 유용

### static 멤버 함수
- **'this' 포인터를 사용할 수 없음**
- **static 멤버 변수와 다른 static 멤버 함수에만 접근 가능**
- 클래스 차원의 유틸리티 함수나 팩토리 함수로 주로 사용

```cpp
class MyClass {
private:
    static int count;        // static 멤버 변수
    int value;
    
public:
    static int getCount() {  // static 멤버 함수
        return count;        // static 멤버에만 접근 가능
        // return value;     // 오류! non-static 멤버에 접근 불가
    }
    
    MyClass() { count++; }   // 생성자에서 카운트 증가
};

int MyClass::count = 0;      // static 멤버 변수 초기화

// 사용법
int total = MyClass::getCount();  // 객체 생성 없이 호출 가능
```

---


### 주요 원칙
- **캡슐화**: 데이터와 함수를 하나로 묶고 접근을 제어
- **정보 은닉**: 내부 구현을 외부로부터 숨김
- **자동 메모리 관리**: 생성자/소멸자를 통한 안전한 리소스 관리
- **타입 안전성**: const 키워드를 통한 의도치 않은 변경 방지